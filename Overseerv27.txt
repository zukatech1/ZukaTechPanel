-- realbunni.com
--// --- Services ---
local CoreGui: CoreGui = game:GetService("CoreGui")
local RunService: RunService = game:GetService("RunService")
local UserInputService: UserInputService = game:GetService("UserInputService")
local TweenService: TweenService = game:GetService("TweenService")
local Players: Players = game:GetService("Players")
local ReplicatedStorage: ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer: Player = Players.LocalPlayer

--// --- Type Definitions ---
type PatchData = {
    Value: any,
    Locked: boolean,
    IsFunction: boolean,
    Original: any?
}

--// --- Registry & State ---
local Registry = {
    ActivePatches = {} :: { [table]: { [any]: PatchData } },
    Hooks = {} :: { [any]: any }
}

local State = {
    SelectedModule = nil,
    CurrentTable = nil,
    PathStack = {},
    Minimized = false,
    ViewingCode = false,
    SearchFilter = ""
}

local SidebarButtons = {}

--// --- PATCH SAVE/LOAD SYSTEM ---
local PatchMemory = {
    Saves = {} :: { [string]: any },
    CurrentSave = nil
}

local function SerializePatch(tbl: table, key: any, value: any): string?
    local keyStr = tostring(key)
    local valueStr = ""
    
    if type(value) == "string" then
        valueStr = "\"" .. value:gsub("\"", "\\\"") .. "\""
    elseif type(value) == "number" or type(value) == "boolean" then
        valueStr = tostring(value)
    elseif typeof(value) == "Color3" then
        valueStr = string.format("Color3.fromRGB(%d,%d,%d)", value.R*255, value.G*255, value.B*255)
    elseif typeof(value) == "Vector3" then
        valueStr = string.format("Vector3.new(%f,%f,%f)", value.X, value.Y, value.Z)
    else
        return nil
    end
    
    return keyStr .. "=" .. valueStr
end

local function SavePatches(saveName: string)
    local snapshot = {}
    for tbl, keys in pairs(Registry.ActivePatches) do
        local tblName = tostring(tbl)
        snapshot[tblName] = {}
        for key, data in pairs(keys) do
            local serialized = SerializePatch(tbl, key, data.Value)
            if serialized then
                table.insert(snapshot[tblName], {
                    Key = tostring(key),
                    Value = data.Value,
                    Serialized = serialized
                })
            end
        end
    end
    
    PatchMemory.Saves[saveName] = {
        Timestamp = tick(),
        Patches = snapshot,
        Count = (function() local c = 0 for _ in pairs(snapshot) do c = c + 1 end return c end)()
    }
    
    return true
end

local function LoadPatches(saveName: string): boolean
    local save = PatchMemory.Saves[saveName]
    if not save then return false end
    
    -- Re-apply all patches from the save
    for tbl, keys in pairs(Registry.ActivePatches) do
        for key, data in pairs(keys) do
            if data.Original then
                pcall(ForceWrite, tbl, key, data.Original)
            end
        end
    end
    
    Registry.ActivePatches = {}
    
    -- Note: This is a simplified loader. Full restoration requires keeping module references
    -- For now, we'll just notify the user they need to re-navigate to the modules
    PatchMemory.CurrentSave = saveName
    return true
end

local GhostRegistry = {
    BlockedRemotes = {},
    SpoofedArguments = {},
    UI_Hidden = true
}

local function CloakEnvironment()
    local mt = getrawmetatable(game)
    local old_index = mt.__index
    setreadonly(mt, false)
    mt.__index = newcclosure(function(t, k)
        if not checkcaller() and k == "OVERSEER_ARCHITECT_V26_PAYLOADS" then
            return nil 
        end
        return old_index(t, k)
    end)
    setreadonly(mt, true)
end

local function InitiateInterception()
    local mt = getrawmetatable(game)
    local old_namecall = mt.__namecall
    setreadonly(mt, false)
    
    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}

        -- [NEW] Intercepting the modern Raycast API (Silent Aim)
        if method == "Raycast" and self == workspace and not checkcaller() then
            local target = ArchitectSuite.GetBestTarget(500)
            if target then
                -- Redirect the direction vector to face the target
                args[2] = (target.Position - args[1]).Unit * 1000 
                return old_namecall(self, unpack(args))
            end
        end

        -- [ORIGINAL] Remote Interception logic
        if (method == "FireServer" or method == "InvokeServer") and GhostRegistry.BlockedRemotes[self.Name] then
            return nil 
        end
        
        return old_namecall(self, ...)
    end)
    setreadonly(mt, true)
end


local function DeepScan()
    if not getgc then return end
    for _, obj in pairs(getgc(true)) do
        if type(obj) == "function" then
            local info = c_info(obj, "n")
            if info:lower():find("anticheat") or info:lower():find("kick") then
                hookfunction(obj, function() return end)
            end
        end
    end
end

local function FreezeConstant(func, constName, newVal)
    for i = 1, 100 do -- Typical constant limit
        local val = debug.getconstant(func, i)
        if val == constName then
            debug.setconstant(func, i, newVal)
            break
        end
    end
end
--// --- Cloaked Function Cache ---
local c_info = clonefunction(debug.info)
local c_check = clonefunction(checkcaller)
local c_rawset = clonefunction(rawset)
local c_getmt = clonefunction(getrawmetatable)

local decompiler = (decompile or decompile_script or function() return "-- [ERROR] Decompiler unsupported on this executor." end)

--// --- Architectural Utilities ---

local function ToggleWriteable(tbl: table, state: boolean): boolean
    local setRO = setreadonly or (make_writeable and function(t, b) if b then make_readonly(t) else make_writeable(t) end end)
    if not setRO then return false end
    local success = pcall(setRO, tbl, state)
    return success
end

local function ForceWrite(tbl: table, key: any, val: any): boolean
    local isRO = false
    if isreadonly then isRO = isreadonly(tbl) end
    if isRO then ToggleWriteable(tbl, false) end
    
    local success, err = pcall(function()
        c_rawset(tbl, key, val)
    end)
    
    if isRO then ToggleWriteable(tbl, true) end
    return success
end

local ArchitectSuite = {
    GetMetatableSafe = function(tbl: table): table?
        local success, mt = pcall(c_getmt, tbl)
        return (success and mt) and mt or nil
    end,

    GetBestTarget = function(dist: number): Instance?
        local target, closest = nil, dist
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                local d = (LocalPlayer.Character.HumanoidRootPart.Position - p.Character.HumanoidRootPart.Position).Magnitude
                if d < closest then
                    target = p.Character.HumanoidRootPart
                    closest = d
                end
            end
        end
        return target
    end,

    UnshackledGetMetatable = function(tbl: table)
        -- This bypasses the "Locked" string trap
        local mt = c_getmt(tbl)
        if mt then
            local success, isRO = pcall(isreadonly, mt)
            if success and isRO then
                ToggleWriteable(mt, false) -- Force it to be writeable
            end
            return mt
        end
        return nil
    end,

    RevealHiddenData = function(tbl: table)
        local hiddenData = {}
        -- If the table is blank, we scan the functions for hidden variables
        for k, v in pairs(tbl) do
            if type(v) == "function" then
                local success, upvalues = pcall(debug.getupvalues, v)
                if success then
                    for i, uv in pairs(upvalues) do
                        hiddenData["UPVALUE_" .. tostring(k) .. "_" .. i] = uv
                    end
                end
            end
        end
        return hiddenData
    end,

    FreezeConstant = function(func, constName, newVal)
        if not debug or not debug.getconstants then return end
        local constants = debug.getconstants(func)
        for i, v in pairs(constants) do
            if v == constName then
                debug.setconstant(func, i, newVal)
                return true
            end
        end
        return false
    end,

    ProxyRaycast = function(originalFunc: any)
        return hookfunction(originalFunc, newcclosure(function(...)
            local result = originalFunc(...)
            local target = ArchitectSuite.GetBestTarget(20)
            if target then
                if typeof(result) == "Instance" then
                    return target
                elseif type(result) == "table" or typeof(result) == "RaycastResult" then
                    pcall(function()
                        ForceWrite(result, "Instance", target)
                        ForceWrite(result, "Position", target.Position)
                        ForceWrite(result, "Hit", target)
                    end)
                end
            end
            return result
        end))
    end
}

-- Assigned after the table literal for clean modularity
ArchitectSuite.HeuristicScan = function()
    local weaponModules = {}
    local keywords = {"damage", "firerate", "recoil", "spread", "ammo", "reload", "velocity"}
    
    for _, m in ipairs(getloadedmodules()) do
        local success, result = pcall(require, m)
        if success and type(result) == "table" then
            local matches = 0
            for k, _ in pairs(result) do
                for _, word in ipairs(keywords) do
                    if tostring(k):lower():find(word) then
                        matches = matches + 1
                    end
                end
            end
            -- If the module has 2+ weapon-related keys, it's likely a gun config
            if matches >= 2 then
                table.insert(weaponModules, {Module = m, Data = result, Confidence = matches})
            end
        end
    end
    return weaponModules
end

ArchitectSuite.GhostHook = function(instance, property, cheatValue)
    local mt = getrawmetatable(game)
    local oldIndex = mt.__index
    setreadonly(mt, false)
    
    mt.__index = newcclosure(function(t, k)
        if not checkcaller() and t == instance and k == property then
            return 16 -- The "Legal" value the game expects to see
        end
        return oldIndex(t, k)
    end)
    instance[property] = cheatValue -- The actual value used for physics
    setreadonly(mt, true)
end

--// --- UI Utilities (MOVED TO TOP TO PREVENT NIL ERRORS) ---
local function applyStyle(obj: Instance, r: number?)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, r or 4)
    c.Parent = obj
end

local function createStroke(obj: Instance, color: Color3)
    local s = Instance.new("UIStroke")
    s.Color = color
    s.Thickness = 1
    s.Transparency = 0.8
    s.Parent = obj
end

--// --- UI Refresh: The "Glass" Theme ---
local function ApplyModernStyle(frame)
    frame.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
    frame.BackgroundTransparency = 0.2
    local blur = Instance.new("Frame")
    blur.Size = UDim2.new(1, 4, 1, 4)
    blur.Position = UDim2.fromOffset(-2, -2)
    blur.BackgroundColor3 = Color3.fromRGB(0, 255, 170)
    blur.BackgroundTransparency = 0.9
    blur.ZIndex = frame.ZIndex - 1
    applyStyle(blur, 8) -- Now it knows what applyStyle is
    blur.Parent = frame
end

--// --- The "Quick Tweak" Dashboard ---
local function CreateSurgicalDashboard()
    local dash = Instance.new("Frame")
    dash.Size = UDim2.fromOffset(300, 400)
    dash.Position = UDim2.new(1, -310, 0.5, -200)
    dash.Parent = screenGui
    ApplyModernStyle(dash)
    applyStyle(dash, 8)

    local titleLabel = Instance.new("TextLabel", dash)
    titleLabel.Size = UDim2.new(1, 0, 0, 30)
    titleLabel.Text = "SURGICAL CONSOLE // WEAPON TUNER"
    titleLabel.TextColor3 = Color3.fromRGB(0, 255, 170)
    titleLabel.Font = Enum.Font.Code
    titleLabel.TextSize = 10
    titleLabel.BackgroundTransparency = 1

    local scroll = Instance.new("ScrollingFrame", dash)
    scroll.Size = UDim2.new(1, -20, 1, -40)
    scroll.Position = UDim2.fromOffset(10, 35)
    scroll.BackgroundTransparency = 1
    scroll.ScrollBarThickness = 2
    scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    local layout = Instance.new("UIListLayout", scroll)
    layout.Padding = UDim.new(0, 5)

    -- Run the scan and populate
    local guns = ArchitectSuite.HeuristicScan()
    for _, gun in ipairs(guns) do
        local btn = Instance.new("TextButton", scroll)
        btn.Size = UDim2.new(1, 0, 0, 25)
        btn.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
        btn.Text = "MODIFY: " .. gun.Module.Name
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.Font = Enum.Font.Code
        btn.TextSize = 9
        applyStyle(btn, 4)
        
        btn.MouseButton1Click:Connect(function()
            PopulateGrid(gun.Data, gun.Module.Name) 
        end)
    end
    return dash
end

--// --- Patching Engine ---
local function ApplyDeepPatch(tbl: table, key: any, val: any, isFunc: boolean)
    if not Registry.ActivePatches[tbl] then Registry.ActivePatches[tbl] = {} end
    
    if isFunc then
        local spoofValue = val
        local originalFunc = tbl[key]
        if hookfunction then
            local newClosure = newcclosure(function(...)
                if spoofValue == "TRUE" then return true end
                if spoofValue == "FALSE" then return false end
                return nil
            end)
            Registry.Hooks[originalFunc] = hookfunction(originalFunc, newClosure)
        end
    else
        -- Store original value before patching
        local original = tbl[key]
        Registry.ActivePatches[tbl][key] = {
            Value = val,
            Locked = true,
            IsFunction = false,
            Original = original
        }
        ForceWrite(tbl, key, val)
    end
end

RunService.Heartbeat:Connect(function()
    for tbl, keys in pairs(Registry.ActivePatches) do
        for key, data in pairs(keys) do
            if data.Locked and not data.IsFunction then
                if tbl[key] ~= data.Value then
                    ForceWrite(tbl, key, data.Value)
                end
            end
        end
    end
end)

--// --- CLEANUP ON RESET/DEATH ---
local function CleanupOnReset()
    for tbl, keys in pairs(Registry.ActivePatches) do
        for key, data in pairs(keys) do
            if data.Original and not data.IsFunction then
                pcall(ForceWrite, tbl, key, data.Original)
            end
        end
    end
    Registry.ActivePatches = {}
    for func, hook in pairs(Registry.Hooks) do
        if hookfunction then
            pcall(hookfunction, func, hook)
        end
    end
    Registry.Hooks = {}
end

task.spawn(CloakEnvironment)
task.spawn(InitiateInterception)



-- task.spawn(DeepScan) -- Optional: Uncomment to auto-disable game anti-cheats

--// --- UI Construction ---
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "OVERSEER_ARCHITECT_V26_PAYLOADS"
screenGui.ResetOnSpawn = false
screenGui.Parent = CoreGui

-- [NEW] Bind the Surgical Dashboard to F4
UserInputService.InputBegan:Connect(function(input, gpe)
    if not gpe and input.KeyCode == Enum.KeyCode.F4 then
        -- Check if it already exists to toggle it
        local existing = screenGui:FindFirstChild("SurgicalDash")
        if existing then
            existing.Visible = not existing.Visible
        else
            local dash = CreateSurgicalDashboard() -- We modify the function slightly below to return the object
            dash.Name = "SurgicalDash"
        end
    end
end)

local main = Instance.new("Frame")
main.Size = UDim2.fromOffset(850, 550)
main.Position = UDim2.new(0.5, -425, 0.5, -275)
main.BackgroundColor3 = Color3.fromRGB(42, 42, 42)
main.BackgroundTransparency = 0.3
main.BorderSizePixel = 0
main.ClipsDescendants = true
main.Parent = screenGui

local function applyStyle(obj: Instance, r: number?)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, r or 4)
    c.Parent = obj
end

local function createStroke(obj: Instance, color: Color3)
    local s = Instance.new("UIStroke")
    s.Color = color
    s.Thickness = 3
    s.Transparency = 0.5
    s.Parent = obj
end

applyStyle(main, 6)
createStroke(main, Color3.fromRGB(255, 85, 99))

-- Header
local header = Instance.new("Frame")
header.Size = UDim2.new(1, 0, 0, 35)
header.BackgroundColor3 = Color3.fromRGB(12, 12, 15)
header.Parent = main


local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -220, 1, 0)
title.Position = UDim2.fromOffset(12, 0)
title.Text = "OVERSEER // V26.1"
title.TextColor3 = Color3.fromRGB(178, 8, 8)
title.Font = Enum.Font.Code
title.TextSize = 11
title.TextXAlignment = Enum.TextXAlignment.Left
title.BackgroundTransparency = 1
title.Parent = header

local backBtn = Instance.new("TextButton")
backBtn.Size = UDim2.new(0, 60, 0, 22)
backBtn.Position = UDim2.new(1, -347, 0.5, -12)
backBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
backBtn.Text = "< BACK"
backBtn.TextColor3 = Color3.new(1, 1, 1)
backBtn.Font = Enum.Font.Code
backBtn.TextSize = 10
applyStyle(backBtn, 3)
backBtn.Parent = header

-- Content Area
local content = Instance.new("Frame")
content.Size = UDim2.new(1, 0, 1, -35)
content.Position = UDim2.fromOffset(0, 35)
content.BackgroundTransparency = 1
content.Parent = main

local searchInput = Instance.new("TextBox")
searchInput.Size = UDim2.new(0, 230, 0, 30)
searchInput.Position = UDim2.fromOffset(10, 10)
searchInput.BackgroundColor3 = Color3.fromRGB(15, 15, 18)
searchInput.PlaceholderText = "SEARCH REGISTRY..."
searchInput.Text = ""
searchInput.TextColor3 = Color3.fromRGB(0, 255, 170)
searchInput.Font = Enum.Font.Code
searchInput.TextSize = 10
applyStyle(searchInput, 4)
createStroke(searchInput, Color3.fromRGB(40, 40, 45))
searchInput.Parent = content

local sidebar = Instance.new("ScrollingFrame")
sidebar.Size = UDim2.new(0, 230, 1, -60)
sidebar.Position = UDim2.fromOffset(10, 50)
sidebar.BackgroundTransparency = 1
sidebar.AutomaticCanvasSize = Enum.AutomaticSize.Y
sidebar.ScrollBarThickness = 1
sidebar.Parent = content
Instance.new("UIListLayout", sidebar).Padding = UDim.new(0, 4)

local grid = Instance.new("ScrollingFrame")
grid.Size = UDim2.new(1, -270, 1, -20)
grid.Position = UDim2.fromOffset(260, 10)
grid.BackgroundColor3 = Color3.fromRGB(12, 12, 15)
grid.BackgroundTransparency = 1
grid.AutomaticCanvasSize = Enum.AutomaticSize.Y
grid.ScrollBarThickness = 1
applyStyle(grid, 4)
createStroke(grid, Color3.fromRGB(30, 30, 35))
grid.Parent = content
local gridList = Instance.new("UIListLayout", grid)

local codeFrame = Instance.new("Frame")
codeFrame.Size = grid.Size
codeFrame.Position = grid.Position
codeFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 12)
codeFrame.Visible = false
applyStyle(codeFrame, 4)
codeFrame.Parent = content

local codeScroller = Instance.new("ScrollingFrame")
codeScroller.Size = UDim2.new(1, -20, 1, -60)
codeScroller.Position = UDim2.fromOffset(10, 10)
codeScroller.BackgroundTransparency = 1
codeScroller.ScrollBarThickness = 1
codeScroller.AutomaticCanvasSize = Enum.AutomaticSize.XY
codeScroller.Parent = codeFrame

local codeBox = Instance.new("TextBox")
codeBox.Size = UDim2.new(1, 0, 1, 0)
codeBox.BackgroundColor3 = Color3.fromRGB(5, 5, 7)
codeBox.TextColor3 = Color3.fromRGB(180, 180, 180)
codeBox.Font = Enum.Font.Code
codeBox.TextSize = 10
codeBox.TextXAlignment = Enum.TextXAlignment.Left
codeBox.TextYAlignment = Enum.TextYAlignment.Top
codeBox.ClearTextOnFocus = false
codeBox.TextEditable = false
codeBox.MultiLine = true
codeBox.Text = ""
applyStyle(codeBox, 4)
codeBox.Parent = codeScroller

local closeCode = Instance.new("TextButton")
closeCode.Size = UDim2.new(0, 100, 0, 30)
closeCode.Position = UDim2.new(0, 10, 1, -40)
closeCode.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
closeCode.Text = "EXIT"
closeCode.TextColor3 = Color3.new(1, 1, 1)
closeCode.Font = Enum.Font.Code
closeCode.TextSize = 10
applyStyle(closeCode, 4)
closeCode.Parent = codeFrame

--// --- Core Logic Functions ---

local function ShowSource(target: any)
    State.ViewingCode = true
    grid.Visible = false
    codeFrame.Visible = true
    title.Text = "DECOMPILING OBJECT..."
    codeBox.Text = "-- Architect Decompiler working..."
    task.spawn(function()
        local src = decompiler(target)
        codeBox.Text = src
    end)
end

local function PopulateGrid(targetTable: table, name: string)
    State.CurrentTable = targetTable
    title.Text = "POISONING PATH: " .. (name or "Unknown")
    
    for _, v in ipairs(grid:GetChildren()) do
        if v:IsA("Frame") then v:Destroy() end
    end
    
    -- Validate that targetTable is actually a table
    if not targetTable or type(targetTable) ~= "table" then
        local emptyMsg = Instance.new("Frame")
        emptyMsg.Size = UDim2.new(1, -10, 0, 50)
        emptyMsg.BackgroundColor3 = Color3.fromRGB(30, 20, 20)
        emptyMsg.Parent = grid
        applyStyle(emptyMsg, 4)
        
        local emptyLabel = Instance.new("TextLabel", emptyMsg)
        emptyLabel.Size = UDim2.new(1, 0, 1, 0)
        emptyLabel.BackgroundTransparency = 1
        emptyLabel.Text = "⚠ Invalid or empty table"
        emptyLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        emptyLabel.Font = Enum.Font.Code
        emptyLabel.TextSize = 10
        return
    end

    -- [NEW] Recursive Metatable Surveillance
    local function ExploreMetatables(tbl, depth, maxDepth)
        if depth == nil then depth = 0 end
        if maxDepth == nil then maxDepth = 5 end
        if depth > maxDepth then return end
        
        local mt = ArchitectSuite.GetMetatableSafe(tbl)
        if not mt then return end
        
        local mtRow = Instance.new("Frame")
        mtRow.Size = UDim2.new(1, -10, 0, 35)
        mtRow.BackgroundColor3 = Color3.fromRGB(35, 15, 55)
        mtRow.Parent = grid
        applyStyle(mtRow, 4)
        
        local depthStr = string.rep("→", depth)
        local mtLabel = Instance.new("TextLabel")
        mtLabel.Size = UDim2.new(0.4, 0, 1, 0)
        mtLabel.Position = UDim2.fromOffset(5, 0)
        mtLabel.Text = depthStr .. " [MT-" .. depth .. "] Inherited Logic"
        mtLabel.TextColor3 = Color3.fromRGB(180, 120, 255)
        mtLabel.Font = Enum.Font.Code
        mtLabel.TextSize = 9
        mtLabel.BackgroundTransparency = 1
        mtLabel.Parent = mtRow

        local mtDive = Instance.new("TextButton")
        mtDive.Size = UDim2.new(0, 70, 0, 22)
        mtDive.Position = UDim2.fromScale(0.45, 0.2)
        mtDive.BackgroundColor3 = Color3.fromRGB(60, 40, 80)
        mtDive.Text = "EXPLORE"
        mtDive.TextColor3 = Color3.new(1, 1, 1)
        mtDive.Font = Enum.Font.Code
        mtDive.TextSize = 8
        applyStyle(mtDive, 2)
        mtDive.Parent = mtRow

        mtDive.MouseButton1Click:Connect(function()
            table.insert(State.PathStack, targetTable)
            PopulateGrid(mt, name .. ".__metatable" .. string.rep(".mt", depth))
        end)
        
        -- Recursively show deeper metatables
        if depth < maxDepth then
            ExploreMetatables(mt, depth + 1, maxDepth)
        end
    end
    
    ExploreMetatables(targetTable, 0, 3)

    local function CreateRow(k: any, v: any, parent: table)
        local row = Instance.new("Frame")
        row.Size = UDim2.new(1, -10, 0, 35)
        row.BackgroundTransparency = 1
        row.Parent = grid

        local keyLabel = Instance.new("TextLabel")
        keyLabel.Size = UDim2.new(0.4, 0, 1, 0)
        keyLabel.Position = UDim2.fromOffset(5, 0)
        keyLabel.Text = "[" .. type(v):upper() .. "] " .. tostring(k)
        keyLabel.TextColor3 = Color3.fromRGB(160, 160, 170)
        keyLabel.Font = Enum.Font.Code
        keyLabel.TextSize = 9
        keyLabel.TextXAlignment = Enum.TextXAlignment.Left
        keyLabel.BackgroundTransparency = 1
        keyLabel.Parent = row

        if type(v) == "table" then
            local dive = Instance.new("TextButton")
            dive.Size = UDim2.new(0, 70, 0, 22)
            dive.Position = UDim2.fromScale(0.45, 0.2)
            dive.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
            dive.Text = "DIVE"
            dive.TextColor3 = Color3.fromRGB(0, 255, 170)
            dive.Font = Enum.Font.Code
            dive.TextSize = 8
            applyStyle(dive, 2)
            dive.Parent = row
            dive.MouseButton1Click:Connect(function()
                table.insert(State.PathStack, parent)
                PopulateGrid(v, tostring(k))
            end)
        elseif type(v) == "function" then
            local hook = Instance.new("TextButton")
            hook.Size = UDim2.new(0, 70, 0, 22)
            hook.Position = UDim2.fromScale(0.45, 0.2)
            hook.BackgroundColor3 = Color3.fromRGB(50, 40, 40)
            hook.Text = "HOOK"
            hook.TextColor3 = Color3.new(1, 1, 1)
            hook.Font = Enum.Font.Code
            hook.TextSize = 8
            applyStyle(hook, 2)
            hook.Parent = row
            
            local view = Instance.new("TextButton")
            view.Size = UDim2.new(0, 70, 0, 22)
            view.Position = UDim2.fromScale(0.55, 0.2)
            view.BackgroundColor3 = Color3.fromRGB(40, 50, 40)
            view.Text = "SOURCE"
            view.TextColor3 = Color3.fromRGB(0, 255, 170)
            view.Font = Enum.Font.Code
            view.TextSize = 8
            applyStyle(view, 2)
            view.Parent = row
            view.MouseButton1Click:Connect(function() ShowSource(v) end)

            local modes = {"NORMAL", "TRUE", "FALSE"}
            local cur = 1
            hook.MouseButton1Click:Connect(function()
                cur = (cur % 3) + 1
                hook.Text = "FORCE " .. modes[cur]
                ApplyDeepPatch(parent, k, modes[cur], true)
            end)

            if debug and debug.getupvalues then
                local upvBtn = Instance.new("TextButton")
                upvBtn.Size = UDim2.new(0, 70, 0, 22)
                upvBtn.Position = UDim2.fromScale(0.65, 0.2)
                upvBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 40)
                upvBtn.Text = "UPVALUES"
                upvBtn.TextColor3 = Color3.new(1, 0.8, 0)
                upvBtn.Font = Enum.Font.Code
                upvBtn.TextSize = 8
                applyStyle(upvBtn, 2)
                upvBtn.Parent = row
                upvBtn.MouseButton1Click:Connect(function()
                    table.insert(State.PathStack, parent)
                    PopulateGrid(debug.getupvalues(v), "UPVALUES: " .. tostring(k))
                end)
            end
        else
            local valInput = Instance.new("TextBox")
            valInput.Size = UDim2.new(0, 120, 0, 22)
            valInput.Position = UDim2.fromScale(0.45, 0.2)
            valInput.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
            valInput.Text = tostring(v)
            valInput.TextColor3 = Color3.new(1, 1, 1)
            valInput.Font = Enum.Font.Code
            valInput.TextSize = 9
            applyStyle(valInput, 2)
            valInput.Parent = row
            valInput.FocusLost:Connect(function(enter)
                if enter then
                    local newVal = tonumber(valInput.Text) or valInput.Text
                    if valInput.Text == "true" then newVal = true elseif valInput.Text == "false" then newVal = false end
                    ApplyDeepPatch(parent, k, newVal, false)
                end
            end)
        end
    end

    pcall(function()
        local itemCount = 0
        for k, v in pairs(targetTable) do
            itemCount = itemCount + 1
            CreateRow(k, v, targetTable)
        end
        
        -- Show message if table is empty
        if itemCount == 0 then
            local emptyMsg = Instance.new("Frame")
            emptyMsg.Size = UDim2.new(1, -10, 0, 50)
            emptyMsg.BackgroundColor3 = Color3.fromRGB(20, 30, 20)
            emptyMsg.Parent = grid
            applyStyle(emptyMsg, 4)
            
            local emptyLabel = Instance.new("TextLabel", emptyMsg)
            emptyLabel.Size = UDim2.new(1, 0, 1, 0)
            emptyLabel.BackgroundTransparency = 1
            emptyLabel.Text = "✓ Table is empty (no keys)"
            emptyLabel.TextColor3 = Color3.fromRGB(100, 200, 100)
            emptyLabel.Font = Enum.Font.Code
            emptyLabel.TextSize = 10
        end
    end)
end

local function AddSidebarItem(obj: any, name: string)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, -5, 0, 28)
    container.BackgroundTransparency = 1
    container.Parent = sidebar

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, -80, 1, 0)
    btn.BackgroundColor3 = Color3.fromRGB(18, 18, 22)
    btn.Text = " " .. name
    btn.TextColor3 = Color3.fromRGB(200, 200, 200)
    btn.Font = Enum.Font.Code
    btn.TextSize = 10
    btn.TextXAlignment = Enum.TextXAlignment.Left
    applyStyle(btn, 3)
    btn.Parent = container

    local payload = Instance.new("TextButton")
    payload.Size = UDim2.new(0, 35, 1, 0)
    payload.Position = UDim2.new(1, -75, 0, 0)
    payload.BackgroundColor3 = Color3.fromRGB(50, 20, 20)
    payload.Text = "PL"
    payload.TextColor3 = Color3.fromRGB(255, 50, 50)
    payload.Font = Enum.Font.Code
    payload.TextSize = 9
    payload.Visible = (name:lower():find("melee") or name:lower():find("combat") or name:lower():find("ray")) ~= nil
    applyStyle(payload, 3)
    payload.Parent = container

    local src = Instance.new("TextButton")
    src.Size = UDim2.new(0, 35, 1, 0)
    src.Position = UDim2.new(1, -35, 0, 0)
    src.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    src.Text = "{}"
    src.TextColor3 = Color3.fromRGB(0, 255, 170)
    src.Font = Enum.Font.Code
    applyStyle(src, 3)
    src.Parent = container

    SidebarButtons[container] = name

    btn.MouseButton1Click:Connect(function()
        State.SelectedModule = obj
        State.PathStack = {}
        local success, result = pcall(require, obj)
        PopulateGrid(success and result or obj, name)
    end)

payload.MouseButton1Click:Connect(function()
        local success, result = pcall(require, obj)
        if success then
            for k, v in pairs(result) do
                if type(v) == "function" then
                    -- Use the new FreezeConstant API to remove Recoil/Spread
                    ArchitectSuite.FreezeConstant(v, "Recoil", 0)
                    ArchitectSuite.FreezeConstant(v, "Spread", 0)
                    
                    if k:lower():find("cooldown") then
                        hookfunction(v, newcclosure(function() return false end))
                    elseif k:lower():find("cast") or k:lower():find("ray") or k:lower():find("hit") then
                        ArchitectSuite.ProxyRaycast(v)
                    end
                end
            end
            payload.Text = "ACTIVE"
            payload.BackgroundColor3 = Color3.fromRGB(0, 255, 170)
            payload.TextColor3 = Color3.fromRGB(0, 0, 0)
        end
    end)
end
--// --- RESCAN BUTTON ---
local scannedModules = {}

local function RescanModules()
    -- Clear the sidebar
    for btn, _ in pairs(SidebarButtons) do
        btn:Destroy()
    end
    SidebarButtons = {}
    
    -- Clear scanned modules
    scannedModules = {}
    
    -- Re-scan everything
    local function scan(root)
        for _, m in ipairs(root:GetDescendants()) do
            if m:IsA("ModuleScript") and not scannedModules[m] then
                scannedModules[m] = true
                AddSidebarItem(m, m.Name)
            end
        end
    end
    
    scan(ReplicatedStorage)
    scan(LocalPlayer)
    
    if getloadedmodules then
        for _, m in ipairs(getloadedmodules()) do
            if not scannedModules[m] then
                scannedModules[m] = true
                AddSidebarItem(m, "[LOADED] " .. tostring(m))
            end
        end
    end
end

local rescanBtn = Instance.new("TextButton")
rescanBtn.Size = UDim2.new(0, 70, 0, 22)
rescanBtn.Position = UDim2.new(1, -140, 0.5, -11)  -- Positioned left of the back button
rescanBtn.BackgroundColor3 = Color3.fromRGB(30, 50, 40)
rescanBtn.Text = "RESCAN"
rescanBtn.TextColor3 = Color3.fromRGB(0, 255, 170)
rescanBtn.Font = Enum.Font.Code
rescanBtn.TextSize = 10
applyStyle(rescanBtn, 3)
rescanBtn.Parent = header

rescanBtn.MouseButton1Click:Connect(RescanModules)

--// --- PATCH SAVE/LOAD BUTTONS ---
local saveBtn = Instance.new("TextButton")
saveBtn.Size = UDim2.new(0, 60, 0, 22)
saveBtn.Position = UDim2.new(1, -210, 0.5, -11)
saveBtn.BackgroundColor3 = Color3.fromRGB(40, 35, 20)
saveBtn.Text = "SAVE"
saveBtn.TextColor3 = Color3.fromRGB(255, 200, 0)
saveBtn.Font = Enum.Font.Code
saveBtn.TextSize = 10
applyStyle(saveBtn, 3)
saveBtn.Parent = header

saveBtn.MouseButton1Click:Connect(function()
    local timestamp = os.date("%H%M%S")
    SavePatches("AutoSave_" .. timestamp)
    saveBtn.Text = "✓"
    saveBtn.BackgroundColor3 = Color3.fromRGB(20, 50, 20)
    task.wait(1)
    saveBtn.Text = "SAVE"
    saveBtn.BackgroundColor3 = Color3.fromRGB(40, 35, 20)
end)

local loadBtn = Instance.new("TextButton")
loadBtn.Size = UDim2.new(0, 60, 0, 22)
loadBtn.Position = UDim2.new(1, -280, 0.5, -11)
loadBtn.BackgroundColor3 = Color3.fromRGB(20, 35, 40)
loadBtn.Text = "LOAD"
loadBtn.TextColor3 = Color3.fromRGB(100, 180, 255)
loadBtn.Font = Enum.Font.Code
loadBtn.TextSize = 10
applyStyle(loadBtn, 3)
loadBtn.Parent = header

loadBtn.MouseButton1Click:Connect(function()
    -- Check if a save list already exists and destroy it
    local existing = screenGui:FindFirstChild("SaveListMenu")
    if existing then
        existing:Destroy()
        return
    end
    
    -- Create a save selection menu
    local saveList = Instance.new("Frame")
    saveList.Name = "SaveListMenu"
    saveList.Size = UDim2.fromOffset(300, 400)
    saveList.Position = UDim2.new(0.5, -150, 0.5, -200)
    saveList.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
    saveList.ZIndex = 1000
    applyStyle(saveList, 8)
    createStroke(saveList, Color3.fromRGB(0, 255, 170))
    saveList.Parent = screenGui
    
    local listTitle = Instance.new("TextLabel", saveList)
    listTitle.Size = UDim2.new(1, 0, 0, 40)
    listTitle.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
    listTitle.Text = "PATCH SAVES"
    listTitle.TextColor3 = Color3.fromRGB(0, 255, 170)
    listTitle.Font = Enum.Font.Code
    listTitle.TextSize = 11
    applyStyle(listTitle, 4)
    
    local scroll = Instance.new("ScrollingFrame", saveList)
    scroll.Size = UDim2.new(1, -20, 1, -60)
    scroll.Position = UDim2.fromOffset(10, 45)
    scroll.BackgroundTransparency = 1
    scroll.ScrollBarThickness = 2
    scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    local layout = Instance.new("UIListLayout", scroll)
    layout.Padding = UDim.new(0, 8)
    
    for saveName, saveData in pairs(PatchMemory.Saves) do
        local saveBtnItem = Instance.new("TextButton", scroll)
        saveBtnItem.Size = UDim2.new(1, -10, 0, 35)
        saveBtnItem.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
        saveBtnItem.Text = saveName .. " (" .. saveData.Count .. " patches)"
        saveBtnItem.TextColor3 = Color3.fromRGB(200, 200, 200)
        saveBtnItem.Font = Enum.Font.Code
        saveBtnItem.TextSize = 9
        applyStyle(saveBtnItem, 4)
        
        saveBtnItem.MouseButton1Click:Connect(function()
            LoadPatches(saveName)
            saveList:Destroy()
        end)
    end
    
    if not next(PatchMemory.Saves) then
        local emptyLabel = Instance.new("TextLabel", scroll)
        emptyLabel.Size = UDim2.new(1, 0, 0, 40)
        emptyLabel.BackgroundTransparency = 1
        emptyLabel.Text = "No saves yet"
        emptyLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
        emptyLabel.Font = Enum.Font.Code
        emptyLabel.TextSize = 10
    end
    
    local closeBtn = Instance.new("TextButton", saveList)
    closeBtn.Size = UDim2.new(0, 100, 0, 30)
    closeBtn.Position = UDim2.new(0.5, -50, 1, -40)
    closeBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
    closeBtn.Text = "CANCEL"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.Code
    closeBtn.TextSize = 9
    applyStyle(closeBtn, 4)
    
    closeBtn.MouseButton1Click:Connect(function()
        if saveList and saveList.Parent then
            saveList:Destroy()
        end
    end)
end)

--// --- RESET/DEATH HANDLERS ---
LocalPlayer.CharacterRemoving:Connect(CleanupOnReset)
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)  -- Wait for character to fully load
    RescanModules()
end)

--// --- Scanner Thread ---
task.spawn(function()
    local processed = {}
    local function scan(root)
        for _, m in ipairs(root:GetDescendants()) do
            if m:IsA("ModuleScript") and not processed[m] then
                processed[m] = true
                AddSidebarItem(m, m.Name)
            end
        end
    end
    scan(ReplicatedStorage)
    scan(LocalPlayer)
    if getloadedmodules then
        for _, m in ipairs(getloadedmodules()) do
            if not processed[m] then
                processed[m] = true
                AddSidebarItem(m, "[LOADED] " .. tostring(m))
            end
        end
    end
end)

--// --- UI Event Binding ---
backBtn.MouseButton1Click:Connect(function()
    if #State.PathStack > 0 then
        local prev = table.remove(State.PathStack)
        PopulateGrid(prev, "Parent Scope")
    end
end)

closeCode.MouseButton1Click:Connect(function()
    State.ViewingCode = false
    codeFrame.Visible = false
    grid.Visible = true
end)

searchInput:GetPropertyChangedSignal("Text"):Connect(function()
    local filter = searchInput.Text:lower()
    for btn, name in pairs(SidebarButtons) do
        btn.Visible = name:lower():find(filter) ~= nil
    end
end)

local minBtn = Instance.new("TextButton", header)
minBtn.Size = UDim2.new(0, 30, 0, 30)
minBtn.Position = UDim2.new(1, -35, 0, 0)
minBtn.Text = "—"
minBtn.TextColor3 = Color3.new(1, 1, 1)
minBtn.BackgroundTransparency = 1
minBtn.MouseButton1Click:Connect(function()
    State.Minimized = not State.Minimized
    content.Visible = not State.Minimized
    TweenService:Create(main, TweenInfo.new(0.3, Enum.EasingStyle.Quart), {
        Size = State.Minimized and UDim2.fromOffset(850, 35) or UDim2.fromOffset(850, 550)
    }):Play()
end)

-- Dragging logic (Same as original)
local dragging, dragStart, startPos
header.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true; dragStart = input.Position; startPos = main.Position
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)
